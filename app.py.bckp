import asyncio
from aiohttp import web
import os
import socket
import random
import aiohttp
import requests
import json

POD_IP = str(os.environ['POD_IP'])
WEB_PORT = int(os.environ['WEB_PORT'])
POD_ID = random.randint(0, 100)
leader = False
web_running = False
other_pods = {}
runner = None  # Global reference to the runner
site = None    # Global reference to the site

async def setup_k8s():
    print("K8S setup completed")

async def serve_cookie():
    global web_running, leader, other_pods, runner, site
    if POD_ID > max(other_pods.values()):
        if web_running:
            return  # If the web server is already started, we don't need to start it again
        else:
            print("Running web")

            app = web.Application()
            app.router.add_get("/", lambda _: web.FileResponse("./index.html"))

            runner = web.AppRunner(app)
            await runner.setup()

            site = web.TCPSite(runner, "0.0.0.0", 80)
            await site.start()
            web_running = True
            return web.Response(status=200)

async def send_election_message(pod_ip):
    try:
        url = f'http://{pod_ip}:{WEB_PORT}/receive_election'
        async with aiohttp.ClientSession() as session:
            async with session.post(url, json={'pod_id': POD_ID}) as response:
                return response.status == 200
    except Exception as e:
        print(f"Error sending election message to {pod_ip}: {e}")
        return False


async def announce_leader():
    for pod_ip in other_pods.keys():
        if pod_ip != POD_IP:  # Don't announce to self
            try:
                url = f'http://{pod_ip}:{WEB_PORT}/receive_coordinator'
                async with aiohttp.ClientSession() as session:
                    await session.post(url, json={'new_leader': POD_ID})
            except Exception as e:
                print(f"Error announcing leader to {pod_ip}: {e}")

async def stop_web_server():
    global web_running, runner, site
    if web_running and runner and site:
        await site.stop()
        await runner.cleanup()
        web_running = False
        print("Web server stopped")

async def run_bully():
    global leader, other_pods
    while True:
        await asyncio.sleep(5)  # Wait for a short period before each iteration

        # Discover other pods
        ip_list = []
        response = socket.getaddrinfo("bully-service", 0, 0, 0, 0)
        for result in response:
            ip_list.append(result[-1][0])
        ip_list = list(set(ip_list))  # Remove duplicates

        # Remove own POD IP from the list
        if POD_IP in ip_list:
            ip_list.remove(POD_IP)
        print(f"Pod {POD_IP} (ID: {POD_ID}) sees the following other pods: {ip_list}")

        # Get IDs of other pods
        other_pods.clear()
        for pod_ip in ip_list:
            endpoint = '/pod_id'
            url = f'http://{pod_ip}:{WEB_PORT}{endpoint}'
            try:
                async with aiohttp.ClientSession() as session:
                    async with session.get(url) as resp:
                        if resp.status == 200:
                            pod_id = await resp.json()
                            other_pods[pod_ip] = pod_id
                            print(f"Pod {pod_ip} has ID {pod_id}")
                        else:
                            print(f"Error getting ID from pod {pod_ip}: {resp.status}")
            except Exception as e:
                print(f"Error in communication with pod {pod_ip}: {e}")

        # Bully algorithm leader election logic
        if not leader:
            higher_pod_alive = False
            for pod_ip in other_pods.keys():
                if other_pods[pod_ip] > POD_ID:
                    if await send_election_message(pod_ip):
                        higher_pod_alive = True
                        break

            if not higher_pod_alive:
                leader = True
                print(f"Pod {POD_IP} (ID: {POD_ID}) is declaring itself as the leader.")
                await announce_leader()
                if not web_running:
                    await serve_cookie()
            else:
                leader = False
                if web_running:
                    await stop_web_server()

        await asyncio.sleep(2)  # Check for leadership status at regular intervals



#GET /pod_id
async def pod_id(request):
    return web.json_response(POD_ID)

#POST /receive_answer
async def receive_answer(request):
    data = await request.json()
    sender_pod_id = data['pod_id']
    if sender_pod_id < POD_ID:
        # Respond to indicate this pod is alive
        return web.Response(status=200)
    return web.Response(status=400)

#POST /receive_election
async def receive_election(request):
    data = await request.json()
    sender_pod_id = data['pod_id']
    if sender_pod_id < POD_ID:
        await run_bully()  # Trigger own election process
        return web.Response(status=200)
    return web.Response(status=400)

#POST /receive_coordinator
async def receive_coordinator(request):
    data = await request.json()
    new_leader = data['new_leader']
    # Update leader information
    global leader
    if new_leader != POD_ID:
        leader = False
        if web_running:
            await stop_web_server()
    return web.Response(status=200)

async def background_tasks(app):
    task = asyncio.create_task(run_bully())
    yield
    task.cancel()
    await task

if __name__ == "__main__":
    app = web.Application()
    app.router.add_get('/pod_id', pod_id)
    app.router.add_post('/receive_answer', receive_answer)
    app.router.add_post('/receive_election', receive_election)
    app.router.add_post('/receive_coordinator', receive_coordinator)
    app.cleanup_ctx.append(background_tasks)
    web.run_app(app, host='0.0.0.0', port=WEB_PORT)
